# Writing Automated Tests

## Foreward

Rust includes support for writing automated tests out of the box and the use of these
tools are strongly encouraged. Rust's compiler does a lot in the way of type and borrow
checking--much more than other languages--to protect against runtime breaks; however,
the compiler is still powerlesss in providing assurances that your code performs as intended.
To test for correctness, Rust provides methods for writing automated tests. This was one of the
many things that drew me to the language, as the included tooling actually looks very promising.

## How to Write Tests

- Test functions generally perfrom the following three actions:
    1. Set up any needed data or state
    2. Run the code you want to test
    3. Assert the results are what you expect them to be

- Rust provides a test attribute, which can be used to set up and run tests,
along with a few macros and the should_panic attribute to get you up and running

### The Anatomy of a Test Function

- Test functions are annotated with the "test" attribute
    - Attributes are metadata about pieces of Rust code
- To declare a function as a test function, we prefix the function with #[test]:

```rust
#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}
```

- When the cargo test command is executed, Rust builds a test runner binary that
runs the functions annotates with the test attribute and reports on whether each
test function passes or fails

### Checking Results with the assert! Macro

- The assert! macro is used to check that some condition in a test evaluates to true.
When the assert! macro is given a boolean argument, it will call the panic! macro if the
received value is false causing the test fail; if it receieves true, it will do nothing:

```rust
#[test]
fn larger_can_hold_smaller() {
    let larger = Rectangle { width: 8, height: 7 };
    let smaller = Rectangle { width: 5, height: 1 };

    assert!(larger.can_hold(&smaller));
}
```

### Testing Equalityu with the assert_eq! and assert_ne! Macros

- Another common way of testing results of your code are to assert expected results
and then run tests against those assertions. We can do that with the assert macros:

```rust
#[test]
fn it_adds_two() {
    assert_eq!(4, add_two(2));
}
```

- **NOTE**: Unlike some other languages, Rust refers to its test arguments as "left" and "right".
Some other testing suites refer to these arguments as expected and actual; because Rust does not
consider arguments in this way, the ordering of test arguments are irrelevant

### Adding Custom Failure Messages

- The assert macros also except optional arguments for custom failure messages:

```rust
#[test]
fn greeting_contains_name() {
    let result = greeting("Carol");
    assert!(
        result.contains("Carol"),
        "Greeting did not contain name, value was `{}`", result
    );
}
```

### Checking for Panics with should_panic

- We should also write tests to check that our code handles errors as expected. To do this,
Rust provides another attribute called should_panic that will check whether or note a function
panics. This is done by adding the #[should_panic] to the function prefix:

```rust
#[test]
#[should_panic]
fn greater_than_100() {
    Guess::new(200);
}
```

- By default, should_panic is does not return details regarding the cause of the panic; it only
confirms whether or not the code panics. To receive more detailed information about the cause of
the panic, we can pass additional arguments to should_panic:

```rust
#[test]
#[should_panic(expected = "Guess value must be less than or equal to 100")]
fn greater_than_100() {
    Guess::new(200);
}
```

### Using Result<T, E> in Tests

Instead of using assertions or should_panic, we can also use Result<T, E> to return information
about the success of our code. This will simply return the Err if the Result returned contains an
error and pass the test if the Result contains Ok. This is a good alternative to get more detailed
information back regarding failures if the particular situation allows.

## Controlling How Tests are Run

### Running Tests in Parallel or Consecutively

- By default, tests are run in parallel using threads. This allows the tests to run faster and provide
feedback more quickly; however, it also means that tests can not depend on each other or access any
shared resources

- We can specify to Cargo how many threads to use to run the tests. This means that we can run tests
consecutively if we instruct Cargo to only use one thread. This is helpful if you need your tests
to be able to access any shared state or resources

### Showing Function Output

- By default, Cargo will only print information generated by the tests to stdout. This means that any
print statements contained within the function calls inside the test itself will not be displayed.
If you want to print this information as well, we can specify this to Cargo with the --show-output flag

### Running a Subset of Tests by Name

- If you wish to run only one or some subset of tests instead of simply running all of them, you can
simply append the names of those tests to the cargo test command

- Alternatively, you can also provide part of a test name as an argument to the cargo test command.
For example, running the command "cargo test add" would run all tests whose name contains "add"

### Ignoring Some Tests Unl;ess Specifically Requested

- There also may be cases in which you only want to run certain tests when specified. To ignore a
test by default when your test suite is run, you can add the #[ignore] attribute below the #[test]
attribute. Tests with this attribute will only be run when you manually instruct Cargo to run them

- To run all ignored tests, you can use the --ignored flag

## Test Organization

The Rust community thinks about tests in terms of two main categories:
    1. Unit Tests
    2. Integration Tests

### Unit Tests

- Unit tests are small and focused; they test one module at a time and can test private interfaces
- These are used to test units of code in isolation and quickly pinpoint where code may not be
working as expected
- Unit tests are written in the same file as the code they are testing
- By convention, a tests module is created in each file that contains tests for functions in that
particular file
- These tests are annotated with the #[cfg(test)] attribute. Using this annotation signifies
that they should not be included in the compiled result
- The cfg attribute stands for "configuration" and tells Rust that items with this attribute
are only to be considered under the specified configuration (in this case test)
- Rust does allow you to test private functions

### Integration Tests
- Integration tests are separate from your library and therefore access code in the way any other
external code would; they can be used to test multiple modules and only use public interfaces
- Integration tests are written and kept in a "tests" directory, which should be located at the
top level of the project directory next to src; Cargo will look here for tests by default
- Each test file in the tests directory will be compiled as an individual crate
- Because integration tests are external crates, libraries and modules must be brought into scope
before they are used
- Files in the test directory are only complied when cargo test is run
- Particular integration test functions may be run by providing their name to cargo test using
the --test flag
